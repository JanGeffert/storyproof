<!DOCTYPE html>
<html>
<head>
	<title>Path finding</title>
</head>
<body>
<canvas id="canvas" width="640" height="640" style="border: 1px solid black;"></canvas>
https://en.wikipedia.org/wiki/A*_search_algorithm#Pseudocode
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script type="text/javascript">
// mathematical helpers
function Vec(x,y) {
	this.x = x;
	this.y = y;
	this.add = function(v) {
		this.x += v.x;
		this.y += v.y;
	};
}

// Config
var dimension = new Vec(16, 16);
var pixelSize = 40;

var playerPos = new Vec(0, 0);
var goal = new Vec(13, 15);
var obstacles = [];
obstacles.push(new Vec(4,4));
obstacles.push(new Vec(5,4));
obstacles.push(new Vec(6,4));
obstacles.push(new Vec(4,5));
obstacles.push(new Vec(4,6));
obstacles.push(new Vec(4,7));
obstacles.push(new Vec(4,8));
obstacles.push(new Vec(4,9));
obstacles.push(new Vec(4,10));
obstacles.push(new Vec(5,11));

// player methods
function isWithinBounds(v) {
	return v.x >= 0 && v.x < dimension.x && v.y >= 0 && v.y < dimension.y;
}

function movePlayer(v) {
	var potentialPos = new Vec(playerPos.x + v.x, playerPos.y + v.y);
	if(isWithinBounds(potentialPos)) {
		playerPos.add(v);
	} else {
		console.log("Tried to move player out of bounds.")
	}
}

// Main
var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');

function drawBoard() {
	for (var x = 0; x < dimension.x; x++) {
		ctx.beginPath();
		ctx.moveTo(x * pixelSize, 0);
		ctx.lineTo(x * pixelSize, dimension.y * pixelSize);
		ctx.stroke();
	}

	for (var y = 0; y < dimension.y; y++) {
		ctx.beginPath();
		ctx.moveTo(0, y * pixelSize);
		ctx.lineTo(dimension.x * pixelSize, y * pixelSize);
		ctx.stroke();
	}
}

function drawElement(pos, color) {
	ctx.fillStyle = color;
	ctx.fillRect(pos.x * pixelSize, pos.y * pixelSize, pixelSize, pixelSize);
}

function drawPlayer() {
	drawElement(playerPos, "red");
}

function isObstacle(v) {
	for (i in obstacles) {
		if(v.x == obstacles[i].x && v.y == obstacles[i].y) {
			return true;
		}
	}
	return false;
}

function drawObstacles() {
	for (i in obstacles) {
		drawElement(obstacles[i], "blue");
	}
}

function drawGoal() {
	drawElement(goal, "green");
}

function drawPath() {
	var currentPos = Object.create(playerPos);
	var futurePath = path.slice();
	while (true) {
		var nextMove = futurePath.shift();
		if (nextMove != null) {
			currentPos.add(nextMove);
			drawElement(currentPos, "rgba(20,20,20,0.2)");
		} else {
			break;
		}
	}	
}

var path;

function draw() {
	ctx.clearRect(0, 0, canvas.width, canvas.height);
	path = findShortestPath(playerPos, goal);
	drawBoard();
	drawObstacles();
	drawGoal();
	drawPlayer();
	drawPath();
}

function update() {
	draw();
	var nextMove = path.shift();
	if (nextMove != null) {
		movePlayer(nextMove);
	} else {
		// console.log("reached goal!");
	}
}

function makeArray(w, h, val) {
    var arr = [];
    for(i = 0; i < h; i++) {
        arr[i] = [];
        for(j = 0; j < w; j++) {
            arr[i][j] = val;
        }
    }
    return arr;
}

function NodeHeap(initialNodes) {
	this.data = initialNodes;
	this.enqueue = function(node) {
		this.data.push(node);
	};
	this.dequeue = function() {
		if (this.data.length == 0) {
			console.log("dequeue called on empty queue");
		} else {
			var lowestFScore = Infinity;
			var lowestNode = null;
			for (var i in this.data) {
				if(this.data[i].fScore <= lowestFScore) {
					lowestFScore = this.data[i].fScore;
					lowestNode = this.data[i];
				}
			}
			this.data.splice(this.data.indexOf(lowestNode), 1);
			return lowestNode;
		}
	};
	this.hasMember = function(v) {
		for (var i in this.data) {
			if(this.data[i].x == v.x && this.data[i].y == v.y) {
				return true;
			}
		}
		return false;
	};
}

function NodeSet(nodeArray) {
	this.data = nodeArray;
	this.add = function(node) {
		this.data.push(node);
	};
	this.hasMember = function(node) {
		for (var i in this.data) {
			if(this.data[i].pos.x == node.x && this.data[i].pos.y == node.y) {
				return true;
			}
		}
		return false;
	};
}

function heuristicCostEstimate(startNode, goalNode) {
	return 42;
}

// Node primitive
function Node(x, y) {
	this.x = x;
	this.y = y;
	// cost of getting from the start to the node
	this.gScore = Infinity;
	// the total cost of getting from the start node to the goal by passing this node
	this.fScore = Infinity;
	// to reconstruct the path eventually
	this.cameFrom = null;
	// neighbors [NeighborNode, NeighborDistance]

	//  0 7 6
	//  1   5
	//  2 3 4 

	this.neighbors = [];

	this.toString = function() {
		return "(" + x + ", " + y + ")";
	}
}

function reconstructPath(current) {
	var totalPath = [current];
	var cameFrom = current.cameFrom;
	
	while (cameFrom != null) {
		current = cameFrom;
		totalPath.push(cameFrom);
		cameFrom = current.cameFrom;
	}

	// console.log(totalPath);

	var steps = [];

	for (var i = totalPath.length - 1; i > 0; i--) {
		// console.log("We want to get from " + i + " to " + i-1);

		steps.push(new Vec(totalPath[i - 1].x - totalPath[i].x, totalPath[i - 1].y - totalPath[i].y));
	}

	return steps;

	// return [new Vec(1,1), new Vec(1,1), new Vec(1,1), new Vec(1,0), new Vec(1,0), new Vec(0,1), new Vec(0,1), new Vec(0,1), new Vec(0,1), new Vec(1,1)];
}

function heuristicCostEstimate(startNode, endNode) {
	var dx = Math.abs(startNode.x - endNode.x)
    var dy = Math.abs(startNode.y - endNode.y)
    return 10 * (dx + dy) + (14 - 2 * 10) * Math.min(dx, dy);
}

function setupNodes() {
	var nodeArray = [];

	for (var x = 0; x < dimension.x; x++) {
		var currentRow = [];
		for (var y = 0; y < dimension.y; y++) {
			var currentNode = new Node(x, y);
			currentRow.push(currentNode);
		}
		nodeArray.push(currentRow);
	}

	for (var x = 0; x < dimension.x; x++) {
		for (var y = 0; y < dimension.y; y++) {
			if(isWithinBounds(new Vec(x-1, y)) && !isObstacle(new Vec(x-1, y))) {
				nodeArray[x][y].neighbors.push([nodeArray[x-1][y], 10]);
			}
			if(isWithinBounds(new Vec(x+1, y)) && !isObstacle(new Vec(x+1, y))) {
				nodeArray[x][y].neighbors.push([nodeArray[x+1][y], 10]);
			}
			if(isWithinBounds(new Vec(x, y-1)) && !isObstacle(new Vec(x, y-1))) {
				nodeArray[x][y].neighbors.push([nodeArray[x][y-1], 10]);
			}
			if(isWithinBounds(new Vec(x, y+1)) && !isObstacle(new Vec(x, y+1))) {
				nodeArray[x][y].neighbors.push([nodeArray[x][y+1], 10]);
			}

			if(isWithinBounds(new Vec(x-1, y-1)) && !isObstacle(new Vec(x-1, y-1))
				&& !(isObstacle(new Vec(x-1, y)) && isObstacle(new Vec(x, y-1)))


				) {
				nodeArray[x][y].neighbors.push([nodeArray[x-1][y-1], 14]);
			}
			if(isWithinBounds(new Vec(x-1, y+1)) && !isObstacle(new Vec(x-1, y+1))
 				&& !(isObstacle(new Vec(x-1, y)) && isObstacle(new Vec(x, y+1)))


				) {
				nodeArray[x][y].neighbors.push([nodeArray[x-1][y+1], 14]);
			}
			if(isWithinBounds(new Vec(x+1, y-1)) && !isObstacle(new Vec(x+1, y-1))

				&& !(isObstacle(new Vec(x+1, y)) && isObstacle(new Vec(x, y-1)))

				) {
				nodeArray[x][y].neighbors.push([nodeArray[x+1][y-1], 14]);
			}
			if(isWithinBounds(new Vec(x+1, y+1)) && !isObstacle(new Vec(x+1, y+1))

				&& !(isObstacle(new Vec(x+1, y)) && isObstacle(new Vec(x, y+1)))

				) {
				nodeArray[x][y].neighbors.push([nodeArray[x+1][y+1], 14]);
			}
		}
	}

	return nodeArray;
}

// returns a list of steps necessary to move from start to goal most efficiently
function findShortestPath(start, goal) {
	var nodes = setupNodes();
	var startNode = nodes[start.x][start.y];
	var goalNode = nodes[goal.x][goal.y];
	startNode.gScore = 0;
	startNode.fScore = heuristicCostEstimate(startNode, goalNode);
	var closedSet = new NodeHeap([]);
	var openSet = new NodeHeap([startNode]);


	while (openSet.data.length > 0) {
		var currentNode = openSet.dequeue();
		closedSet.enqueue(currentNode);
		// console.log("Dequeued " + currentNode.toString());

		if (currentNode == goalNode) {
			// console.log("Path found, now need to reconstruct.");
			return reconstructPath(goalNode);
		}

		for (i in currentNode.neighbors) {
			var neighborNode = currentNode.neighbors[i][0];
			var neighborDist = currentNode.neighbors[i][1];

			if (closedSet.hasMember(neighborNode)) {
				continue;
			}
			if (!openSet.hasMember(neighborNode)) {
				openSet.enqueue(neighborNode);
			}

			var tentativeGScore = currentNode.gScore + neighborDist;
			if (tentativeGScore >= neighborNode.gScore) {
				continue;
			}

			neighborNode.cameFrom = currentNode;
			neighborNode.gScore = tentativeGScore;
			neighborNode.fScore = neighborNode.gScore + heuristicCostEstimate(neighborNode, goalNode);
		}
	}
}

draw();
update();
setInterval(update, 750);

function pixelToVec(x, y) {
	return (new Vec(Math.floor(x / pixelSize), Math.floor(y / pixelSize)));
}

// listener, using W3C style for example    
canvas.addEventListener('click', function(e) {
    console.log('click: ' + e.offsetX + '/' + e.offsetY);
    // console.log();
    obstacles.push(pixelToVec(e.offsetX, e.offsetY));
}, false);



</script>
</body>
</html>