<!DOCTYPE html>
<html>
<head>
	<title>Path finding</title>
</head>
<body>
<canvas id="canvas" width="640" height="640" style="border: 1px solid black;"></canvas>
https://en.wikipedia.org/wiki/A*_search_algorithm#Pseudocode
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script type="text/javascript">
// mathematical helpers
function Vec(x,y) {
	this.x = x;
	this.y = y;
	this.add = function(v) {
		this.x += v.x;
		this.y += v.y;
	};
}

// Config
var dimension = new Vec(16, 16);
var pixelSize = 40;

var playerPos = new Vec(0, 0);
var goal = new Vec(6, 8);
var obstacles = [];
obstacles.push(new Vec(4,4));
obstacles.push(new Vec(4,5));
obstacles.push(new Vec(4,6));
obstacles.push(new Vec(4,7));

// player methods
function isWithinBounds(v) {
	return v.x >= 0 && v.x < dimension.x && v.y >= 0 && v.y < dimension.y;
}

function movePlayer(v) {
	var potentialPos = new Vec(playerPos.x + v.x, playerPos.y + v.y);
	if(isWithinBounds(potentialPos)) {
		playerPos.add(v);
	} else {
		console.log("Tried to move player out of bounds.")
	}
}

// Main
var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');

function drawBoard() {
	for (var x = 0; x < dimension.x; x++) {
		ctx.beginPath();
		ctx.moveTo(x * pixelSize, 0);
		ctx.lineTo(x * pixelSize, dimension.y * pixelSize);
		ctx.stroke();
	}

	for (var y = 0; y < dimension.y; y++) {
		ctx.beginPath();
		ctx.moveTo(0, y * pixelSize);
		ctx.lineTo(dimension.x * pixelSize, y * pixelSize);
		ctx.stroke();
	}
}

function drawElement(pos, color) {
	ctx.fillStyle = color;
	ctx.fillRect(pos.x * pixelSize, pos.y * pixelSize, pixelSize, pixelSize);
}

function drawPlayer() {
	drawElement(playerPos, "red");
}

function drawObstacles() {
	for (i in obstacles) {
		drawElement(obstacles[i], "blue");
	}
}

function drawGoal() {
	drawElement(goal, "green");
}

function drawPath() {
	var currentPos = Object.create(playerPos);
	var futurePath = path.slice();
	while (true) {
		var nextMove = futurePath.shift();
		if (nextMove != null) {
			currentPos.add(nextMove);
			drawElement(currentPos, "rgba(20,20,20,0.2)");
		} else {
			break;
		}
	}	
}

function draw() {
	ctx.clearRect(0, 0, canvas.width, canvas.height);
	drawBoard();
	drawObstacles();
	drawGoal();
	drawPath();
	drawPlayer();
}

var path = findShortestPath(playerPos, goal);

function update() {
	draw();
	var nextMove = path.shift();
	if (nextMove != null) {
		movePlayer(nextMove);
	} else {
		console.log("reached goal!");
	}
}

function makeArray(w, h, val) {
    var arr = [];
    for(i = 0; i < h; i++) {
        arr[i] = [];
        for(j = 0; j < w; j++) {
            arr[i][j] = val;
        }
    }
    return arr;
}

function minQueue() {
	this.data = [];
	this.enqueue = function(v, score) {
		this.data.push({"pos": v, "score": score});
		console.log("enqueue: (" + v.x + ", " + v.y + ") with score " + score);
	}
	this.dequeue = function() {
		if (this.data.length == 0) {
			console.log("dequeue called on empty queue");
		} else {
			var lowestScore = Infinity;
			var lowestKey = 0;
			for (var i in this.data) {
				if(this.data[i].score < lowestScore) {
					lowestScore = this.data.score;
					lowestKey = i;
				}
			}
			return this.data[lowestKey].pos
		}
	}
	this.hasMember = function(v) {
		for (var i in this.data) {
			if(this.data[i].pos.x == v.x && this.data[i].pos.y == v.y) {
				return true;
			}
		}
		return false;
	}
}

function heuristicCostEstimate(start, goal) {
	return 42;
}

// returns a list of steps necessary to move from start to goal most efficiently
function findShortestPath(start, goal) {
	// var closedSet = minQueue();
	// var openSet = minQueue();
	// openSet.enqueue(start, heuristicCostEstimate(start, goal));
	// var cameFrom = makeArray(dimension.x, dimension.y, nil);
	// var gScore = makeArray(dimension.x, dimension.y, Infinity);
	// gScore[start.x][start.y] = 0;
	// var fScore = makeArray(dimension.x, dimension.y, Infinity);
	// fScore[start.x][start.y] = heuristicCostEstimate(start, goal);

	// while (openSet.length > 0) {
	// 	var current = openSet.dequeue();
	// 	if (current == goal) {
	// 		console.log("Path found, now need to reconstruct.");
	// 	}
	// 	closedSet.enqueue(current);

	// 	var neighbors = findNeighbors(current);
	// 	for i in neighbors {
	// 		if closedSet.hasMember(neighbors[i]) {
	// 			continue;
	// 		}
	// 		if !openSet.hasMember(neighbors[i]) {
	// 			openSet.enqueue
	// 		}

	// 		var tentativeGScore = gScore[neighbors[i].x][neighbors[i].y] + distBetween(current, neighbors[i]);
	// 		if (tentativeGScore >= gScore[neighbors[i].x][neighbors[i].y]) {
	// 			continue;
	// 		}

	// 		gScore[neighbors[i].x][neighbors[i].y] = tentativeGScore;


	// 	}
	// }
	return [new Vec(1,1), new Vec(1,1), new Vec(1,1), new Vec(1,0), new Vec(1,0), new Vec(0,1), new Vec(0,1), new Vec(0,1), new Vec(0,1), new Vec(1,1)];
}

draw();

setInterval(update, 1000);
</script>
</body>
</html>