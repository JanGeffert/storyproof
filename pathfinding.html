https://en.wikipedia.org/wiki/A*_search_algorithm#Pseudocode

<!DOCTYPE html>
<html>
<head>
	<title>Path finding</title>
</head>
<body>
<canvas id="canvas" width="640" height="640" style="border: 1px solid black;"></canvas>
<script type="text/javascript">
// mathematical helpers
function Vec(x,y) {
	this.x = x;
	this.y = y;
	this.add = function(v) {
		this.x += v.x;
		this.y += v.y;
	};
}

// Config
var dimension = new Vec(16, 16);
var pixelSize = 40;

var playerPos = new Vec(0, 0);
var goal = new Vec(6, 8);
var obstacles = [];
obstacles.push(new Vec(4,4));
obstacles.push(new Vec(4,5));
obstacles.push(new Vec(4,6));
obstacles.push(new Vec(4,7));

// player methods
function isWithinBounds(v) {
	return v.x >= 0 && v.x < dimension.x && v.y >= 0 && v.y < dimension.y;
}

function movePlayer(v) {
	var potentialPos = new Vec(playerPos.x + v.x, playerPos.y + v.y);
	if(isWithinBounds(potentialPos)) {
		playerPos.add(v);
	} else {
		console.log("Tried to move player out of bounds.")
	}
}

// Main
var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');

function drawBoard() {
	for (var x = 0; x < dimension.x; x++) {
		ctx.beginPath();
		ctx.moveTo(x * pixelSize, 0);
		ctx.lineTo(x * pixelSize, dimension.y * pixelSize);
		ctx.stroke();
	}

	for (var y = 0; y < dimension.y; y++) {
		ctx.beginPath();
		ctx.moveTo(0, y * pixelSize);
		ctx.lineTo(dimension.x * pixelSize, y * pixelSize);
		ctx.stroke();
	}
}

function drawElement(pos, color) {
	ctx.fillStyle = color;
	ctx.fillRect(pos.x * pixelSize, pos.y * pixelSize, pixelSize, pixelSize);
}

function drawPlayer() {
	drawElement(playerPos, "red");
}

function drawObstacles() {
	for (i in obstacles) {
		drawElement(obstacles[i], "blue");
	}
}

function drawGoal() {
	drawElement(goal, "green");
}

function draw() {
	ctx.clearRect(0, 0, canvas.width, canvas.height);
	drawBoard();
	drawPlayer();
	drawObstacles();
	drawGoal();
}

function update() {
	draw();
	movePlayer(new Vec(1, 0));
}

function makeArray(w, h, val) {
    var arr = [];
    for(i = 0; i < h; i++) {
        arr[i] = [];
        for(j = 0; j < w; j++) {
            arr[i][j] = val;
        }
    }
    return arr;
}

function minQueue() {
	this.data = [];
	this.enqueue = function(v, score) {
		this.data.push({"pos": v, "score": score});
		console.log("enqueue: (" + v.x + ", " + v.y + ") with score " + score);
	}
	this.dequeue = function() {
		if (this.data.length == 0) {
			console.log("dequeue called on empty queue");
		} else {
			var lowestScore = Infinity;
			var lowestKey = 0;
			for (var i in this.data) {
				if(this.data[i].score < lowestScore) {
					lowestScore = this.data.score;
					lowestKey = i;
				}
			}
			return this.data[lowestKey].pos
		}
	}
	this.hasMember = function(v) {
		for i in this.data {
			if(this.data[i].pos.x == v.x && this.data[i].pos.y == v.y) {
				return true;
			}
		}
		return false;
	}
}

function heuristicCostEstimate(start, goal) {
	return 42;
}

function findShortestPath(start, goal) {
	var closedSet = minQueue();
	var openSet = minQueue();
	openSet.enqueue(start, heuristicCostEstimate(start, goal));
	var cameFrom = makeArray(dimension.x, dimension.y, nil);
	var gScore = makeArray(dimension.x, dimension.y, Infinity);
	gScore[start.x][start.y] = 0;
	var fScore = makeArray(dimension.x, dimension.y, Infinity);
	fScore[start.x][start.y] = heuristicCostEstimate(start, goal);

	while (openSet.length > 0) {
		var current = openSet.dequeue();
		if (current == goal) {
			console.log("Path found, now need to reconstruct.");
		}
		closedSet.enqueue(current);

		var neighbors = findNeighbors(current);
		for i in neighbors {
			if closedSet.hasMember(neighbors[i]) {
				continue;
			}
			if !openSet.hasMember(neighbors[i]) {
				openSet.enqueue
			}
		}
	}
}

draw();

setInterval(update, 1000);
</script>
</body>
</html>